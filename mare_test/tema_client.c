/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "tema.h"

// used for reading data into it
char buf[BUFSIZE];

user_db *user_database;
int size_database;

request_access_token_response execute_request_client(char *user_id, int auto_refresh, CLIENT* clnt) {
	request_access_token_response response;
	response.fail = 0;
	
	request_authorization_param param;
	
	param.user_id = user_id;
	param.auto_refresh = 0;

	token *authz_token = request_authorization_1(&param, clnt);

	if (authz_token == NULL) {
		printf("USER_NOT_FOUND\n");
		response.fail = 1;
		return response;
	}

	approve_request_token_response *response_approve_request = approve_request_token_1(authz_token, clnt);

	request_access_token_param param_access_token;
	param_access_token.authz_token = response_approve_request->authz_token;
	param_access_token.auto_refresh = auto_refresh;
	param_access_token.user_id = user_id;


	response = *(request_access_token_1(&param_access_token, clnt));

	if (response.fail == 1) {
		printf("REQUEST_DENIED\n");
		return response;
	}

	printf("%s -> %s", response_approve_request->authz_token.token_value, response.access_token.token_value);

	if (auto_refresh) {
		printf(",%s", response.refresh_token.token_value);
	}

	printf("\n");

	return response;
}

void execute_operation_client(char *host, char *filename_operations) {
	CLIENT *clnt;
	/*
	token  *result_1;
	request_authorization_param  request_authorization_1_arg;
	approve_request_token_response  *result_2;
	token  approve_request_token_1_arg;
	request_access_token_response  *result_3;
	request_access_token_param  request_access_token_1_arg;
	validate_delegated_action_response  *result_4;
	validate_delegated_action_param  validate_delegated_action_1_arg;
	*/

	#ifndef	DEBUG
		clnt = clnt_create (host, CHEKPROG, CHECKVERS, "udp");
		if (clnt == NULL) {
			clnt_pcreateerror (host);
			exit (1);
		}
	#endif	/* DEBUG */


	FILE *fp = fopen(filename_operations, "r");
	if (fp == NULL) {
		printf("Cannot open %s\n", filename_operations);
		exit(1);
	}

	const char delimiter[2] = ",";

	char *user_id;
	char *operation;
	char *option;

	while (fgets(buf, BUFSIZE, fp)) {
		user_id = strtok(buf, delimiter);
		operation = strtok(NULL, delimiter);
		option = strtok(NULL, delimiter);

		// printf("%s will do %s on %s", user_id, operation, option);

		if (strncmp(operation, "REQUEST", strlen(operation)) == 0) {
			// options represents auto_refresh
			int auto_refresh = atoi(option);

			request_access_token_response response_request = execute_request_client(user_id, auto_refresh, clnt);

			if (response_request.fail) {
				continue;
			}


			int user_exists = 0;
			int position_to_add = size_database;
			// check if user does not already exist in database and if it does, replace anything but user_id
			for (int i = 0; i < size_database; i++) {
				if (strncmp(user_database[i].user_id, user_id, SIZE_USER_ID) == 0) {
					user_exists = 1;
					position_to_add = i;
					break;
				}
			}

			if (user_exists == 0) {
				user_database = realloc(user_database, (size_database + 1) * sizeof(user_db));
				user_database[size_database].user_id = (char *) calloc(SIZE_USER_ID + 1,sizeof(char));
				user_database[size_database].access_token.token_value = (char *) calloc(SIZE_USER_ID + 1,sizeof(char));
				user_database[size_database].refresh_token.token_value = (char *) calloc(SIZE_USER_ID + 1,sizeof(char));
				strncpy(user_database[size_database].user_id, user_id, SIZE_USER_ID);
				size_database++;
			}


			strncpy(user_database[position_to_add].access_token.token_value, response_request.access_token.token_value, SIZE_USER_ID);
			user_database[position_to_add].access_token.no_available_operations = response_request.access_token.no_available_operations;
			strncpy(user_database[position_to_add].refresh_token.token_value, response_request.refresh_token.token_value, SIZE_USER_ID);


			// permissions doesn't really matter as the pdf mentions
			//  întoarce un jeton de acces la resurse, un jeton pentru regenerarea celui de acces si
			// o perioadă de valabilitate a acestora.

			user_database[position_to_add].list_permissions_val = NULL;
			user_database[position_to_add].list_permissions_len = 0;

			/*
			for (int i = 0; i < size_database; i++) {
				printf("user[%d].access_token.user_id: %s\n", i, user_database[i].user_id);
				printf("user[%d].access_token.token_value: %s\n", i, user_database[i].access_token.token_value);
				printf("user[%d].access_token.token_value.no_available_ops: %d\n", i, user_database[i].access_token.no_available_operations);
				printf("user[%d].refresh_token.token_value: %s\n", i, user_database[i].refresh_token.token_value);
			}
			*/
			

			// printf("auto_refresh: %d\n", auto_refresh);
		} else {
			// option is the resource accesed so we let's remove the \n at the end of it
			// for all rows read from client.in except the last one
			if (option[strlen(option) - 1] == '\n') {
				option[strlen(option) - 1] = '\0';
			}

			validate_delegated_action_param action_param;

			action_param.user_id = (char *) calloc(SIZE_USER_ID + 1, sizeof(char));
			strncpy(action_param.user_id, user_id, SIZE_USER_ID);
			action_param.resource = (char *) calloc(BUFSIZE, sizeof(char));
			action_param.action = (char *) calloc(BUFSIZE, sizeof(char));
			strncpy(action_param.resource, option, strlen(option));
			strncpy(action_param.action, operation, strlen(operation));

			int i;
			for (i = 0; i < size_database; i++) {
				if (strncmp(user_database[i].user_id, user_id, SIZE_USER_ID) == 0) {
					action_param.access_token = user_database[i].access_token;
					break;
				}
			}

			validate_delegated_action_1(&action_param, clnt);

			if (i == size_database) continue;
			user_database[i].access_token.no_available_operations--;
		}
	}

	#ifndef	DEBUG
	clnt_destroy (clnt);
	#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;
	user_database = (user_db *) calloc(1, sizeof(user_db));

	if (argc !=  3) {
		printf ("usage: %s server_host <fisier_operatii> \n", argv[0]);
		exit (1);
	}


	host = argv[1];
	execute_operation_client(host, argv[2]);
	exit (0);
}
